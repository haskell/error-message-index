<p>In this example, we use a <code>let</code> binding to unpack the constructor of a GADT. Naively, this should work fine, because there is only one constructor. Yet GHC does not accept this code!</p>
<p>The fix is to use pattern-matching, either with a <code>case</code> or by pattern-matching in a function argument.</p>
<p>For more details about why this is necessary, see the <a href="https://downloads.haskell.org/ghc/latest/docs/users_guide/exts/existential_quantification.html#restrictions">GHC user guide on ExistentialQuantification</a>.</p>
<p>Note: this example generates GHC-46956 because the <code>TypeFamilies</code> extension is active. If it isn’t, <a href="../../../messages/GHC-25897">GHC-25897</a> is generated instead.</p>
<h2 id="message">Message</h2>
<pre><code>Let.hs:9:18: error: [GHC-46956]
    • Couldn't match expected type ‘a0’ with actual type ‘a’
        because type variable ‘a’ would escape its scope
      This (rigid, skolem) type variable is bound by
        a pattern with constructor:
          MkShowable :: forall a. Show a =&gt; a -&gt; Showable,
        in a pattern binding
        at Let.hs:9:7-18
    • In the pattern: MkShowable x
      In a pattern binding: MkShowable x = showable
      In the expression: let MkShowable x = showable in show x
  |
9 |   let MkShowable x = showable
  |                  ^</code></pre>

<pre class="filename">Let.hs</pre>
<div class="example-container">
  <div class="example">
    <div class="example-inner">
      <div class="example-title">Before</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format properly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE TypeFamilies #-}
module Main where

data Showable where
  MkShowable :: Show a => a -> Showable

showShowable :: Showable -> String
showShowable showable =
  let MkShowable x = showable
  in show x

main :: IO ()
main = putStrLn $ showShowable (MkShowable 42)
</code></pre>
    </div>
  </div>
  <div class="example">
    <div class="example-inner">
      <div class="example-title">After</div>
      <!-- keep next line as is, i.e., on one line, or the code will not format propertly -->
      <pre class="example-pre"><code class="language-haskell">{-# LANGUAGE TypeFamilies #-}
module Main where

data Showable where
  MkShowable :: Show a => a -> Showable

showShowable :: Showable -> String
showShowable showable =
  case showable of
    MkShowable x -> show x

main :: IO ()
main = putStrLn $ showShowable (MkShowable 42)
</code></pre>
    </div>
  </div>
</div>

